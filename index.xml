<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>ロボットシステム入門</title><link>https://matsuolab.github.io/roomba_hack/</link><atom:link href="https://matsuolab.github.io/roomba_hack/index.xml" rel="self" type="application/rss+xml"/><description>ロボットシステム入門</description><generator>Wowchemy (https://wowchemy.com)</generator><language>ja</language><copyright>© 2022 Tokyo Robot And Intelligence Lab (TRAIL)</copyright><lastBuildDate>Tue, 05 Apr 2022 00:00:00 +0000</lastBuildDate><image><url>https://matsuolab.github.io/roomba_hack/media/icon_hua2ec155b4296a9c9791d015323e16eb5_11927_512x512_fill_lanczos_center_2.png</url><title>ロボットシステム入門</title><link>https://matsuolab.github.io/roomba_hack/</link></image><item><title>ロボットシステムにおけるセンシング・アクチュエーション・通信②</title><link>https://matsuolab.github.io/roomba_hack/course/chap3/sensing2/</link><pubDate>Tue, 05 Apr 2022 00:00:00 +0000</pubDate><guid>https://matsuolab.github.io/roomba_hack/course/chap3/sensing2/</guid><description>&lt;p>複数のセンサを組み合わせてよりかしこくロボットを動かしてみよう&lt;/p>
&lt;h2 id="learn">Learn&lt;/h2>
&lt;p>&lt;a href="../../chap2/sensing1/#%e6%bc%94%e7%bf%92">前回の演習&lt;/a>では，速度と時間の指令を使ってロボットを制御しました．&lt;/p>
&lt;p>周囲に障害物が何もない状況や，ロボットの滑りがない環境では，速度と時間のコマンドを使って思った通りにロボットを動かすことができるかもしれませんが，実環境では，ロボットの周囲には障害物が存在しますし，移動距離で制御する方が直感的です．&lt;/p>
&lt;p>前回の演習のようにロボットに速度と時間を一回与えて，その通りに動かすようなフィードフォワード制御ではなく，今回は，ロボットが逐次的にセンサの情報を反映して振る舞いを変える&lt;mark>フィードバック制御&lt;/mark>を行なってみましょう．&lt;/p>
&lt;h3 id="オドメトリのセンサ情報を使ってロボットを動かしてみよう">オドメトリのセンサ情報を使ってロボットを動かしてみよう&lt;/h3>
&lt;p>まずは，ロボットのタイヤの回転量から計算される移動距離である&lt;mark>オドメトリ（odometry）&lt;/mark>を使った制御をしてみましょう．&lt;/p>
&lt;h4 id="オドメトリのメッセージodomの中身を見てみよう">オドメトリのメッセージ（&lt;code>/odom&lt;/code>）の中身を見てみよう&lt;/h4>
&lt;p>roombaのオドメトリの情報は，&lt;code>/odom&lt;/code>トピックにpublishされています．&lt;/p>
&lt;p>&lt;code>rostopic echo /odom&lt;/code>をしてみるとメッセージとしてどんな情報が流れているかわかります．
&lt;details class="spoiler " id="spoiler-2">
&lt;summary>&lt;code>rostopic echo -n 1 /odom&lt;/code>&lt;/summary>
&lt;p>&lt;pre>&lt;code class="language-bash">root@dynamics:~/roomba_hack# rostopic echo -n 1 /odom
header:
seq: 2115
stamp:
secs: 1649692132
nsecs: 791056254
frame_id: &amp;quot;odom&amp;quot;
child_frame_id: &amp;quot;base_footprint&amp;quot;
pose:
pose:
position:
x: -0.014664691872894764
y: -0.0010878229513764381
z: 0.0
orientation:
x: 0.0
y: 0.0
z: 0.0056752621080531414
w: 0.9999838955703261
covariance: [0.08313143998384476, 0.00019857974257320166, 0.0, 0.0, 0.0, 0.004368376452475786, 0.00019857988809235394, 0.015032557770609856, 0.0, 0.0, 0.0, -0.26573312282562256, 0.0, 0.0, 1e-05, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 1e-05, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 1e-05, 0.0, 0.0043683769181370735, -0.26573312282562256, 0.0, 0.0, 0.0, 6.021446704864502]
twist:
twist:
linear:
x: 0.0
y: 0.0
z: 0.0
angular:
x: 0.0
y: 0.0
z: 0.0
covariance: [0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 1e-05, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 1e-05, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 1e-05, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0]
---
&lt;/code>&lt;/pre>
&lt;/p>
&lt;/details>&lt;/p>
&lt;p>&lt;code>rostopic type /odom&lt;/code>をしてみると，メッセージとして，&lt;code>nav_msgs/Odometry&lt;/code>型が使われていることがわかります．
&lt;details class="spoiler " id="spoiler-3">
&lt;summary>&lt;code>rostopic type /odom&lt;/code>&lt;/summary>
&lt;p>&lt;pre>&lt;code class="language-bash">root@dynamics:~/roomba_hack# rostopic type /odom
nav_msgs/Odometry
&lt;/code>&lt;/pre>
&lt;/p>
&lt;/details>&lt;/p>
&lt;p>&lt;code>nav_msgs/Odometry&lt;/code>型の&lt;a href="http://docs.ros.org/en/noetic/api/nav_msgs/html/msg/Odometry.html" target="_blank" rel="noopener">ドキュメント&lt;/a>を確認してみると，このメッセージは&lt;code>pose&lt;/code>と&lt;code>twist&lt;/code>で構成されていることがわかります．&lt;/p>
&lt;p>&lt;code>pose&lt;/code>は．（&lt;code>child_frame&lt;/code>から見た）ロボットの推定姿勢（位置と回転角）を表していて，&lt;code>covariance&lt;/code>にはその不確かさを表す共分散が記録されています．&lt;/p>
&lt;p>一方，&lt;code>twist&lt;/code>は，（&lt;code>child_frame&lt;/code>から見た）ロボットの速度を表していて，&lt;code>pose&lt;/code>と同様に&lt;code>covariance&lt;/code>にはその不確かさを表す共分散が記録されています．&lt;/p>
&lt;p>なお，メッセージ型の定義は，&lt;code>rosmsg info nav_msgs/Odometry&lt;/code>することでもコマンドから確認できます．
&lt;details class="spoiler " id="spoiler-4">
&lt;summary>&lt;code>rosmsg info nav_msgs/Odometry&lt;/code>&lt;/summary>
&lt;p>&lt;pre>&lt;code class="language-bash">root@dynamics:~/roomba_hack# rosmsg info nav_msgs/Odometry
std_msgs/Header header
uint32 seq
time stamp
string frame_id
string child_frame_id
geometry_msgs/PoseWithCovariance pose
geometry_msgs/Pose pose
geometry_msgs/Point position
float64 x
float64 y
float64 z
geometry_msgs/Quaternion orientation
float64 x
float64 y
float64 z
float64 w
float64[36] covariance
geometry_msgs/TwistWithCovariance twist
geometry_msgs/Twist twist
geometry_msgs/Vector3 linear
float64 x
float64 y
float64 z
geometry_msgs/Vector3 angular
float64 x
float64 y
float64 z
float64[36] covariance
&lt;/code>&lt;/pre>
&lt;/p>
&lt;/details>&lt;/p>
&lt;h4 id="クォータニオンquaternion">クォータニオン(quaternion)&lt;/h4>
&lt;p>さて，&lt;code>/odom&lt;/code>のトピックでは，ロボットの回転角は&lt;mark>クォータニオン（quaternion）&lt;/mark>で記述されています．&lt;/p>
&lt;p>クォータニオンは，日本語では四元数と呼ばれ，3次元空間上での回転角を表現する方法の一つで，4つの要素を持つベクトルで表現されます．&lt;/p>
&lt;p>クォータニオンによる3次元回転の表現は，角度を連続的にかつ簡潔に表現できるためROSではよく用いられます（その他には，オイラー角による表現や回転行列による表現があります）．&lt;/p>
&lt;p>それぞれの回転角に関する表現のメリット・デメリットを調べてみましょう（「ジンバルロック」などのキーワードで調べるとよりよく理解できると思います）．&lt;/p>
&lt;p>クォータニオンからオイラー角へは，&lt;code>tf&lt;/code>パッケージの&lt;code>tf.transformations.euler_from_quaternion&lt;/code>を使うことで変換できます（&lt;a href="http://docs.ros.org/en/jade/api/tf/html/python/transformations.html#tf.transformations.euler_from_quaternion" target="_blank" rel="noopener">ドキュメント&lt;/a>）．&lt;/p>
&lt;h4 id="サブスクライバsubscriberの仕組みを知ろう">サブスクライバ（subscriber)の仕組みを知ろう&lt;/h4>
&lt;p>それでは，オドメトリ&lt;code>/odom&lt;/code>の情報を使った制御の実装の例として&lt;code>navigation_tutorial&lt;/code>パッケージの中の&lt;code>simple_control2.py&lt;/code>を見てみましょう（&lt;a href="https://github.com/matsuolab/roomba_hack/blob/master/catkin_ws/src/navigation_tutorial/scripts/simple_control2.py" target="_blank" rel="noopener">github&lt;/a>）．&lt;/p>
&lt;p>前回までに強調されてきた通り，ROSは非同期分散のシステムを簡単に作ることができるのが特徴です．
そのため，ロボットから非同期に送られてくる&lt;code>/odom&lt;/code>の情報をうまく扱うことが重要です．&lt;/p>
&lt;p>実装例にあるように，Pythonによるノードの実装では，クラスとして定義するのがわかりやすい方法でしょう．&lt;/p>
&lt;p>実装例では，&lt;code>SimpleControlller&lt;/code>クラスとして，&lt;code>simple_controller&lt;/code>というノードを定義しています．
以下のように，ノードを初期化する際に，コマンドを&lt;code>/cmd_vel&lt;/code>トピックに送信するパブリッシャ（publisher)と，&lt;code>/odom&lt;/code>を受信するサブスクライバ(subscriber)を作成しています．&lt;/p>
&lt;pre>&lt;code class="language-python">class SimpleController:
def __init__(self):
rospy.init_node('simple_controller', anonymous=True)
# Publisher
self.cmd_vel_pub = rospy.Publisher('/cmd_vel', Twist, queue_size=10)
# Subscriber
odom_sub = rospy.Subscriber('/odom', Odometry, self.callback_odom)
self.x = None
self.y = None
self.yaw = None
while self.x is None:
rospy.sleep(0.1)
&lt;/code>&lt;/pre>
&lt;p>パブリッシャの使い方は前回の&lt;code>simple_control.py&lt;/code>の&lt;a href="https://github.com/matsuolab/roomba_hack/blob/master/catkin_ws/src/navigation_tutorial/scripts/simple_control.py" target="_blank" rel="noopener">実装&lt;/a>を確認してください．&lt;/p>
&lt;p>パブリッシャと同様に，サブスクライバは&lt;code>rospy&lt;/code>の&lt;code>Subscriber&lt;/code>を用いて作成できます．
サブスクライバの特徴として，メッセージを受信した時の処理である&lt;mark>コールバック（callback）&lt;/mark>を定義できます．&lt;/p>
&lt;p>この実装例では，&lt;code>self.callback_odom&lt;/code>として定義されており，インスタンスの属性（&lt;code>self.x&lt;/code>, &lt;code>self.y&lt;/code>, &lt;code>self.yaw&lt;/code>）を，受信したメッセージで変更するようなプログラムになっています．&lt;/p>
&lt;pre>&lt;code class="language-python"> def callback_odom(self, data):
self.x = data.pose.pose.position.x
self.y = data.pose.pose.position.y
self.yaw = self.get_yaw_from_quaternion(data.pose.pose.orientation)
&lt;/code>&lt;/pre>
&lt;p>つまり，&lt;code>self.x&lt;/code>には&lt;code>/odom&lt;/code>から受信した位置のx座標，&lt;code>self.y&lt;/code>には位置のy座標，&lt;code>self.yaw&lt;/code>には，回転角のyawを格納しています．&lt;/p>
&lt;p>クォータニオンとして受信した姿勢の回転角のyaw成分を取り出すための&lt;code>self.get_yaw_from_quaternion&lt;/code>は以下のようになっています（オイラー角はroll, pitch, yawの順で返ってくるので&lt;code>e[2]&lt;/code>でyawを取得しています）．&lt;/p>
&lt;pre>&lt;code class="language-python"> def get_yaw_from_quaternion(self, quaternion):
e = tf.transformations.euler_from_quaternion(
(quaternion.x, quaternion.y, quaternion.z, quaternion.w))
return e[2]
&lt;/code>&lt;/pre>
&lt;p>これらのセンサの値を使うことで，以下のように，指定した距離ロボットが移動するまで直進させ続けたり，指定した角度までロボットが回転するまで回転させ続けることができるようになります．&lt;/p>
&lt;p>直進&lt;/p>
&lt;pre>&lt;code class="language-python"> def go_straight(self, dis, velocity=0.3):
vel = Twist()
x0 = self.x
y0 = self.y
while(np.sqrt((self.x-x0)**2+(self.y-y0)**2)&amp;lt;dis):
vel.linear.x = velocity
vel.angular.z = 0.0
self.cmd_vel_pub.publish(vel)
rospy.sleep(0.1)
self.stop()
&lt;/code>&lt;/pre>
&lt;p>右回転&lt;/p>
&lt;pre>&lt;code class="language-python"> def turn_right(self, yaw, yawrate=-0.5):
vel = Twist()
yaw0 = self.yaw
while(abs(self.yaw-yaw0)&amp;lt;np.deg2rad(yaw)):
vel.linear.x = 0.0
vel.angular.z = yawrate
self.cmd_vel_pub.publish(vel)
rospy.sleep(0.1)
self.stop()
&lt;/code>&lt;/pre>
&lt;p>左回転&lt;/p>
&lt;pre>&lt;code class="language-python"> def turn_left(self, yaw, yawrate=0.5):
vel = Twist()
yaw0 = self.yaw
while(abs(self.yaw-yaw0)&amp;lt;np.deg2rad(yaw)):
vel.linear.x = 0.0
vel.angular.z = yawrate
self.cmd_vel_pub.publish(vel)
rospy.sleep(0.1)
self.stop()
&lt;/code>&lt;/pre>
&lt;p>それでは，オドメトリを使って実際にロボットを制御してみましょう．&lt;/p>
&lt;h2 id="演習">演習&lt;/h2>
&lt;details class="spoiler " id="spoiler-7">
&lt;summary>【jetson・開発マシン】ブランチをmaster切り替えて最新の状態にする&lt;/summary>
&lt;p>&lt;pre>&lt;code class="language-shell">cd roomba_hack
git fetch
git checkout master
git pull origin master
./BUILD-DOCKER-IMAGE.sh
&lt;/code>&lt;/pre>
&lt;/p>
&lt;/details>
&lt;details class="spoiler " id="spoiler-8">
&lt;summary>【jetson・開発マシン】それぞれdockerコンテナを起動&lt;/summary>
&lt;p>&lt;p>注：前回との間に仕様が変わりました（簡単になりました）．
以下のコマンドの&lt;code>&amp;lt;&amp;lt;IP ADDRESS&amp;gt;&amp;gt;&lt;/code>の部分を自分のroomba（jetson）のIPアドレスに変更して起動してください（例：192.168.10.70）．&lt;/p>
&lt;pre>&lt;code class="language-shell">cd roomba_hack
./RUN-DOCKER-CONTAINER.sh &amp;lt;&amp;lt;IP ADDRESS&amp;gt;&amp;gt;
&lt;/code>&lt;/pre>
&lt;/p>
&lt;/details>
&lt;details class="spoiler " id="spoiler-9">
&lt;summary>【jetson・開発マシン】ビルドをしてパスを通す&lt;/summary>
&lt;p>&lt;p>try it! パスを通した後にcatkin_wsの中にあるパッケージが一覧&lt;code>rospack list&lt;/code>に追加されているかを確認してみよう&lt;/p>
&lt;pre>&lt;code class="language-shell">(docker) cd catkin_ws
(docker) catkin_make
(docker) source ./devel/setup.bash
&lt;/code>&lt;/pre>
&lt;/p>
&lt;/details>
&lt;details class="spoiler " id="spoiler-10">
&lt;summary>【jetson】ROSマスタ、各種ノードを起動&lt;/summary>
&lt;p>&lt;pre>&lt;code class="language-shell">(docker) roslaunch roomba_bringup bringup.launch
&lt;/code>&lt;/pre>
&lt;/p>
&lt;/details>
&lt;h3 id="rosメッセージの可視化">ROSメッセージの可視化&lt;/h3>
&lt;details class="spoiler " id="spoiler-11">
&lt;summary>【開発PC】topicの確認&lt;/summary>
&lt;p>&lt;p>&lt;code>/odom&lt;/code>の型を確認&lt;/p>
&lt;pre>&lt;code class="language-shell">(docker) rostopic type /odom
&lt;/code>&lt;/pre>
&lt;p>&lt;code>/odom&lt;/code>の中身を確認&lt;/p>
&lt;pre>&lt;code class="language-shell">(docker) rostopic echo /odom
&lt;/code>&lt;/pre>
&lt;/p>
&lt;/details>
&lt;details class="spoiler " id="spoiler-12">
&lt;summary>オドメトリを使ったフィードバック制御&lt;/summary>
&lt;p>&lt;p>&lt;code>simple_control2.py&lt;/code>を実行してみよう．&lt;/p>
&lt;p>このプログラムを動かすときには，コントローラの&lt;code>Y&lt;/code>ボタンを押してから&lt;code>B&lt;/code>ボタンを押して&lt;code>auto&lt;/code>モードにしておきましょう．&lt;/p>
&lt;p>1メートルほど前に進んだあと，左に90度程度旋回し，右に90度程度旋回したら成功です．&lt;/p>
&lt;pre>&lt;code class="language-shell">(docker) rosrun navigation_tutorial simple_control2.py
&lt;/code>&lt;/pre>
&lt;p>try it! &lt;code>simple_control2.py&lt;/code>の中身を読んでコードを変更してみよう&lt;/p>
&lt;/p>
&lt;/details></description></item><item><title>Localization</title><link>https://matsuolab.github.io/roomba_hack/course/chap4/localization/</link><pubDate>Sat, 22 Jan 2022 00:00:00 +0000</pubDate><guid>https://matsuolab.github.io/roomba_hack/course/chap4/localization/</guid><description>&lt;h2 id="learn">Learn&lt;/h2>
&lt;h3 id="tf">TF&lt;/h3>
&lt;h3 id="自己位置推定">自己位置推定&lt;/h3>
&lt;h2 id="演習">演習&lt;/h2>
&lt;details class="spoiler " id="spoiler-0">
&lt;summary>Dockerfileにmaclを追加してBuildする&lt;/summary>
&lt;p>&lt;/p>
&lt;/details>
&lt;details class="spoiler " id="spoiler-1">
&lt;summary>amclをlaunchして、自己位置推定する&lt;/summary>
&lt;p>&lt;/p>
&lt;/details>
&lt;details class="spoiler " id="spoiler-2">
&lt;summary>amclのparamをチューニングする&lt;/summary>
&lt;p>&lt;/p>
&lt;/details></description></item><item><title>開発環境</title><link>https://matsuolab.github.io/roomba_hack/course/chap1/%E9%96%8B%E7%99%BA%E7%92%B0%E5%A2%83/</link><pubDate>Fri, 01 Jan 2021 00:00:00 +0000</pubDate><guid>https://matsuolab.github.io/roomba_hack/course/chap1/%E9%96%8B%E7%99%BA%E7%92%B0%E5%A2%83/</guid><description>&lt;p>ロボットシステムの開発環境に使われている要素の概要を理解する&lt;/p>
&lt;h2 id="スライド">スライド&lt;/h2>
&lt;p>&lt;a href="https://docs.google.com/presentation/d/1-q6zq3vV91GTj7mw9uqwT4B8LyHDpFHBNVi4lEyCa5A/edit?usp=sharing">https://docs.google.com/presentation/d/1-q6zq3vV91GTj7mw9uqwT4B8LyHDpFHBNVi4lEyCa5A/edit?usp=sharing&lt;/a>&lt;/p>
&lt;h2 id="learn">Learn&lt;/h2>
&lt;h3 id="linuxコマンド">Linuxコマンド&lt;/h3>
&lt;table>
&lt;thead>
&lt;tr>
&lt;th>command&lt;/th>
&lt;th>　説明&lt;/th>
&lt;th>option&lt;/th>
&lt;/tr>
&lt;/thead>
&lt;tbody>
&lt;tr>
&lt;td>ls&lt;/td>
&lt;td>ディレクトリ内のファイル・ディレクトリの表示&lt;/td>
&lt;td>-l: 詳細を表示 -a: 全て表示&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>mkdir&lt;/td>
&lt;td>ディレクトリ作成&lt;/td>
&lt;td>&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>cd&lt;/td>
&lt;td>ディレクトリ移動&lt;/td>
&lt;td>&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>mv&lt;/td>
&lt;td>ファイル移動&lt;/td>
&lt;td>&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>rm&lt;/td>
&lt;td>ファイル削除&lt;/td>
&lt;td>-r:ディレクトリ内を再起的に削除 -f:強制削除&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>cat&lt;/td>
&lt;td>&lt;/td>
&lt;td>&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>&lt;/td>
&lt;td>&lt;/td>
&lt;td>&lt;/td>
&lt;/tr>
&lt;/tbody>
&lt;/table>
&lt;h3 id="ssh">ssh&lt;/h3>
&lt;pre>&lt;code>ssh &amp;lt;username&amp;gt;@&amp;lt;hostname&amp;gt; -p &amp;lt;port&amp;gt; -i &amp;lt;identity_file&amp;gt;
&lt;/code>&lt;/pre>
&lt;h3 id="エディタ">エディタ&lt;/h3>
&lt;ul>
&lt;li>vim
&lt;ul>
&lt;li>チュートリアル： &lt;code>vimtuter&lt;/code>&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>emacs&lt;/li>
&lt;/ul>
&lt;h3 id="gitgithub">git/GitHub&lt;/h3>
&lt;ul>
&lt;li>gitとは
&lt;ul>
&lt;li>add&lt;/li>
&lt;li>push&lt;/li>
&lt;li>pull&lt;/li>
&lt;li>fetch&lt;/li>
&lt;li>clone&lt;/li>
&lt;li>merge&lt;/li>
&lt;li>reset&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>
&lt;h2 id="githubとは">GitHubとは&lt;/h2>
&lt;/li>
&lt;/ul>
&lt;h3 id="docker">docker&lt;/h3>
&lt;ul>
&lt;li>
&lt;p>Dockerとは&lt;/p>
&lt;/li>
&lt;li>
&lt;p>DockerFileのビルド&lt;/p>
&lt;pre>&lt;code>docker build -t &amp;lt;image_name&amp;gt;:&amp;lt;tag_name&amp;gt; -f &amp;lt;Dockerfile&amp;gt; &amp;lt;relative_dir&amp;gt;
&lt;/code>&lt;/pre>
&lt;/li>
&lt;li>
&lt;p>Docker Image&lt;/p>
&lt;pre>&lt;code># Docker image一覧
docker images
# Docker Imageのダウンロード
docker pull &amp;lt;image_name&amp;gt;:&amp;lt;tag_name&amp;gt;
# 削除
docker rmi &amp;lt;image_id&amp;gt;
# 不要なDocker imageを消す
docker image prune
&lt;/code>&lt;/pre>
&lt;/li>
&lt;li>
&lt;p>Docker Container&lt;/p>
&lt;pre>&lt;code># Docker containerの起動
docker run &amp;lt;image_name&amp;gt; &amp;lt;command&amp;gt;
# Docker container一覧
docker ps -a
# Docker containerに接続
docker exec -it &amp;lt;container_name&amp;gt; bash
&lt;/code>&lt;/pre>
&lt;p>※&lt;code>docker run&lt;/code>でよく使うオプション&lt;/p>
&lt;ul>
&lt;li>&lt;code>-it&lt;/code>
&lt;ul>
&lt;li>標準入出力有効になる&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>&lt;code>--name &amp;lt;container_name&amp;gt;&lt;/code>
&lt;ul>
&lt;li>コンテナの名前の指定&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>&lt;code>--rm&lt;/code>
&lt;ul>
&lt;li>コンテナを抜けた際に自動的にコンテナを削除する&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>&lt;code>--gpus all&lt;/code>
&lt;ul>
&lt;li>コンテナに全gpuを渡す&lt;/li>
&lt;li>gpuの個数を指定する場合は all の代わりに数字(0, 1,&amp;hellip;)&lt;/li>
&lt;li>gpuを指定する場合は &lt;code>--gpus '&amp;quot;device=0,1&amp;quot;'&lt;/code>&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>&lt;code>-v &amp;lt;host/path/to/dir:container/path/to/dir&amp;gt;&lt;/code>
&lt;ul>
&lt;li>コンテナ内にホストのディレクトリをマウントする&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>&lt;code>-p &amp;lt;host_port&amp;gt;:&amp;lt;container_port&amp;gt;&lt;/code>
&lt;ul>
&lt;li>ホストのポートをコンテナのポートにマップする&lt;/li>
&lt;li>コンテナ内でwebサーバを動かす場合などに使う&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>&lt;code>--net=host&lt;/code>
&lt;ul>
&lt;li>コンテナとホストでネットワークを共有する(IPアドレスなどが同じになる)&lt;/li>
&lt;li>ROSノードをコンテナ内で動かす場合などはこれを使うと楽&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>&lt;code>--privileged&lt;/code>
&lt;ul>
&lt;li>コンテナからのデバイスへのアクセスを許可&lt;/li>
&lt;li>コンテナからWEBカメラにアクセスしたいときなど&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;h2 id="演習">演習&lt;/h2>
&lt;details class="spoiler " id="spoiler-0">
&lt;summary>【ssh】開発用PCにsshする&lt;/summary>
&lt;p>&lt;pre>&lt;code class="language-shell">vim ~/.ssh/config
ssh robot_dev2
&lt;/code>&lt;/pre>
&lt;/p>
&lt;/details>
&lt;details class="spoiler " id="spoiler-1">
&lt;summary>【Linuxコマンド】個人のディレクトリを作成し移動する&lt;/summary>
&lt;p>&lt;pre>&lt;code class="language-shell">robot_dev2@robot-dev2:~$ mkdir yikeda
robot_dev2@robot-dev2:~$ cd yikeda
&lt;/code>&lt;/pre>
&lt;/p>
&lt;/details>
&lt;details class="spoiler " id="spoiler-2">
&lt;summary>【git】roomba_hackリポジトリをcloneし移動する&lt;/summary>
&lt;p>&lt;pre>&lt;code class="language-shell">robot_dev2@robot-dev2:~/yikeda$ git clone https://github.com/matsuolab/roomba_hack.git
robot_dev2@robot-dev2:~/yikeda$ cd roomba_hack
&lt;/code>&lt;/pre>
&lt;/p>
&lt;/details>
&lt;details class="spoiler " id="spoiler-3">
&lt;summary>【git】devブランチにcheckoutする&lt;/summary>
&lt;p>&lt;pre>&lt;code class="language-shell">robot_dev2@robot-dev2:~/yikeda/roomba_hack$ git checkout dev
&lt;/code>&lt;/pre>
&lt;/p>
&lt;/details>
&lt;details class="spoiler " id="spoiler-4">
&lt;summary>【docker】roomba_hackの開発環境のdocker imageをビルドする&lt;/summary>
&lt;p>&lt;pre>&lt;code>robot_dev2@robot-dev2:~/yikeda/roomba_hack$ ./BUILD-DOCKER-IMAGE.sh
&lt;/code>&lt;/pre>
&lt;/p>
&lt;/details>
&lt;details class="spoiler " id="spoiler-5">
&lt;summary>【ssh】jetsonにsshする&lt;/summary>
&lt;p>&lt;pre>&lt;code class="language-shell">robot_dev2@robot-dev2:~/yikeda/roomba_hack$ ssh roomba_dev1
&lt;/code>&lt;/pre>
&lt;/p>
&lt;/details>
&lt;details class="spoiler " id="spoiler-6">
&lt;summary>【ssh】VNCを使う&lt;/summary>
&lt;p>&lt;pre>&lt;code class="language-shell">robot_dev2@robot-dev2:~/yikeda/roomba_hack$ exit
ssh robot_dev2 -L 5900:localhost:5900
&lt;/code>&lt;/pre>
&lt;p>手元のVNC viewerでlocalhost:5900を開く&lt;/p>
&lt;/p>
&lt;/details></description></item><item><title>ロボットシステムにおけるセンシング・アクチュエーション・通信①</title><link>https://matsuolab.github.io/roomba_hack/course/chap2/sensing1/</link><pubDate>Tue, 05 Apr 2022 00:00:00 +0000</pubDate><guid>https://matsuolab.github.io/roomba_hack/course/chap2/sensing1/</guid><description>&lt;p>センサの値を読み取りロボットを動かしてみよう&lt;/p>
&lt;h2 id="learn">Learn&lt;/h2>
&lt;h3 id="ロボットセンサの基礎知識">ロボットセンサの基礎知識&lt;/h3>
&lt;p>ロボットが動作するために必要なセンサは大きく2種類に分けられる。&lt;/p>
&lt;p>1つ目が外界センサで、これはロボットが行動する環境の情報を取得するためのセンサーである。
具体的なセンサとして、&lt;/p>
&lt;ul>
&lt;li>LiDAR&lt;/li>
&lt;li>デプスカメラ&lt;/li>
&lt;li>ホイールエンコーダ&lt;/li>
&lt;li>IMU&lt;/li>
&lt;/ul>
&lt;p>などがあげられる。&lt;/p>
&lt;p>センサのノイズの影響を軽減するため、複数のセンサを組み合わせて利用されることもある。&lt;/p>
&lt;p>2つ目は内界センサで、これは(ロボットアームのような変形可能な)ロボットが自身の内部状態を把握し、位置や姿勢を制御するために使われるセンサーである。&lt;/p>
&lt;ul>
&lt;li>関節位置・角度センサ&lt;/li>
&lt;li>関節姿勢センサ&lt;/li>
&lt;/ul>
&lt;p>などが内界センサである。&lt;/p>
&lt;p>参考&lt;/p>
&lt;ul>
&lt;li>&lt;a href="https://www.jsme.or.jp/jsme-medwiki/14:1013897#:~:text=robot%20sensor">https://www.jsme.or.jp/jsme-medwiki/14:1013897#:~:text=robot%20sensor&lt;/a>&lt;/li>
&lt;/ul>
&lt;h3 id="rosのパッケージ">ROSのパッケージ&lt;/h3>
&lt;p>ROSのプログラムはパッケージとして管理される。&lt;/p>
&lt;p>navigation_tutorailパッケージのファイル構成を示す。&lt;/p>
&lt;pre>&lt;code>navigation_tutorial
   ├── CMakeLists.txt
   ├── launch
   │   ├── amcl.launch
   │   ├── avoidance.launch
   │   ├── gmapping.launch
   │   ├── go_straight.launch
   │   ├── localization.launch
   │   ├── map_server.launch
   │   ├── move_base.launch
   │   └── navigation.launch
   ├── package.xml
   ├── params
   │   ├── base_global_planner_params.yaml
   │   ├── base_local_planner_params.yaml
   │   ├── costmap_common_params.yaml
   │   ├── dwa_local_planner_params.yaml
   │   ├── global_costmap_params.yaml
   │   ├── local_costmap_params.yaml
   │   └── move_base_params.yaml
   ├── scripts
   │   ├── avoidance.py
   │   ├── simple_control2.py
   │   └── simple_control.py
   └── src
   ├── avoidance.cpp
   └── go_straight.cpp
&lt;/code>&lt;/pre>
&lt;p>作成したプログラムは&lt;code>rosrun&lt;/code>コマンドで実行することができる。&lt;/p>
&lt;pre>&lt;code class="language-shell">(Python) rosrun navigation_tutorail simple_control2.py
(C++) rosrun navigation_tutorail go_straight
&lt;/code>&lt;/pre>
&lt;p>launchファイルについてでも同様に&lt;code>roslaunch&lt;/code>コマンドで実行することができる。&lt;/p>
&lt;pre>&lt;code class="language-shell">(Python) roslaunch navigation_tutorial move_base.launch
&lt;/code>&lt;/pre>
&lt;p>実行時にパッケージを指定するので、(パスが通ってさえれば)ディレクトリに関係なく実行が可能である。&lt;/p>
&lt;h3 id="rosのワークスペース">ROSのワークスペース&lt;/h3>
&lt;p>ROSのパッケージはワークスペースと呼ばれる作業スペースに配置される。&lt;/p>
&lt;p>一般的に&lt;code>catkin_ws&lt;/code>という名前が使われることが多い。&lt;/p>
&lt;p>catkin_wsのファイル構成を示す。&lt;/p>
&lt;pre>&lt;code>catkin_ws
   ├── build
   ├── devel
   └── src
   ├── CMakeLists.txt
   ├── navigation_tutorial
   │   ├── CMakeLists.txt
   │   ├── launch
   │   ├── package.xml
   │   ├── params
   │   ├── scripts
   │   └── src
   └── roomba
   ├── roomba_bringup
   │   ├── CMakeLists.txt
   │   ├── config
   │   ├── launch
   │   └── package.xml
   ├── roomba_description
   │   ├── CMakeLists.txt
   │   ├── config
   │   ├── launch
   │   ├── meshes
   │   ├── package.xml
   │   └── urdf
   ├── roomba_gazebo
   │   ├── CMakeLists.txt
   │   ├── launch
   │   └── package.xml
   └── roomba_teleop
   ├── CMakeLists.txt
   ├── include
   ├── launch
   ├── package.xml
   └── src
&lt;/code>&lt;/pre>
&lt;p>catkin_wsのsrc内でパッケージ作成を行い、catkin_ws直下で&lt;code>catkin_make&lt;/code>コマンドでビルドをすると、buildディレクトリとdevelディレクトリが作成される。&lt;/p>
&lt;p>develディレクトリの中のsetup.bashをソース&lt;code>source devel/setup.bash&lt;/code>することで、ワークスペース内のパッケージのパスを通すことができる。　&lt;/p>
&lt;h3 id="rosのコマンド">ROSのコマンド&lt;/h3>
&lt;p>ROSのコマンドのうち、よく用いるものを紹介する。&lt;/p>
&lt;ul>
&lt;li>Topic関連&lt;/li>
&lt;/ul>
&lt;pre>&lt;code>rostopic list topicの一覧を表示する
rostopic echo 指定されたtopicの中身を表示する
rostopic hz topicの配信周波数を取得する
rostopic info topicの情報を表示する
rostopic pub topicを配信する
rostopic type topicの型を確認する
&lt;/code>&lt;/pre>
&lt;ul>
&lt;li>Node関連&lt;/li>
&lt;/ul>
&lt;pre>&lt;code>rosnode list nodeの一覧を表示する
rosnode ping nodeの接続テストを行う
rosnode info nodeの情報を表示する
rosnode kill nodeをシャットダウンする
&lt;/code>&lt;/pre>
&lt;ul>
&lt;li>Package関連&lt;/li>
&lt;/ul>
&lt;pre>&lt;code>rospack list packageの一覧を表示する
roscd 指定したpackage内に移動する
&lt;/code>&lt;/pre>
&lt;h2 id="演習">演習&lt;/h2>
&lt;details class="spoiler " id="spoiler-0">
&lt;summary>【jetson・開発マシン】ブランチ切り替え&lt;/summary>
&lt;p>&lt;pre>&lt;code class="language-shell">cd roomba_hack
git fetch
git checkout lec_0405
&lt;/code>&lt;/pre>
&lt;/p>
&lt;/details>
&lt;details class="spoiler " id="spoiler-1">
&lt;summary>【jetson・開発マシン】それぞれdockerコンテナを起動&lt;/summary>
&lt;p>&lt;p>try it! roomba_modeの前後で&lt;code>echo $ROS_MASTER_URI&lt;/code>をしてみよう&lt;/p>
&lt;p>参考(ROS_MASTER_URIについて)&lt;/p>
&lt;ul>
&lt;li>&lt;a href="https://qiita.com/srs/items/7d4aeb5e44138f97c770">https://qiita.com/srs/items/7d4aeb5e44138f97c770&lt;/a>&lt;/li>
&lt;/ul>
&lt;pre>&lt;code class="language-shell">cd roomba_hack
./RUN-DOCKER-CONTAINER.sh
(docker) roomba_mode
&lt;/code>&lt;/pre>
&lt;/p>
&lt;/details>
&lt;details class="spoiler " id="spoiler-2">
&lt;summary>【jetson・開発マシン】ビルドをしてパスを通す&lt;/summary>
&lt;p>&lt;p>try it! パスを通した後にcatkin_wsの中にあるパッケージが一覧&lt;code>rospack list&lt;/code>に追加されているかを確認してみよう&lt;/p>
&lt;pre>&lt;code class="language-shell">(docker) cd catkin_ws
(docker) catkin_make
(docker) source ./devel/setup.bash
&lt;/code>&lt;/pre>
&lt;/p>
&lt;/details>
&lt;details class="spoiler " id="spoiler-3">
&lt;summary>【jetson】ROSマスタ、各種ノードを起動&lt;/summary>
&lt;p>&lt;p>try it! &lt;code>bringup.launch&lt;/code>の中身を読んでみよう&lt;/p>
&lt;p>hint &lt;code>roscd &amp;lt;パッケージ名&amp;gt;&lt;/code>とするとパッケージへ簡単に移動ができる&lt;/p>
&lt;pre>&lt;code class="language-shell">(docker) roslaunch roomba_bringup bringup.launch
&lt;/code>&lt;/pre>
&lt;/p>
&lt;/details>
&lt;details class="spoiler " id="spoiler-4">
&lt;summary>【jetson】RealSenseを起動&lt;/summary>
&lt;p>&lt;pre>&lt;code class="language-shell"> cd realsense_docker
./launch_realsense.sh
&lt;/code>&lt;/pre>
&lt;/p>
&lt;/details>
&lt;h3 id="rosメッセージの可視化">ROSメッセージの可視化&lt;/h3>
&lt;details class="spoiler " id="spoiler-5">
&lt;summary>【開発PC】topicの確認&lt;/summary>
&lt;p>&lt;p>topic一覧を表示&lt;/p>
&lt;pre>&lt;code class="language-shell">(docker) rostopic list
&lt;/code>&lt;/pre>
&lt;p>特定のtopicの型を確認&lt;/p>
&lt;pre>&lt;code class="language-shell">(docker) rostopic type /camera/color/image_raw
(docker) rostopic type /scan
&lt;/code>&lt;/pre>
&lt;p>sensor_msgs/LaserScan型 &lt;a href="http://docs.ros.org/en/melodic/api/sensor_msgs/html/msg/LaserScan.html">http://docs.ros.org/en/melodic/api/sensor_msgs/html/msg/LaserScan.html&lt;/a>
sensor_msgs/Image型 &lt;a href="http://docs.ros.org/en/noetic/api/sensor_msgs/html/msg/Image.html">http://docs.ros.org/en/noetic/api/sensor_msgs/html/msg/Image.html&lt;/a>&lt;/p>
&lt;p>特定のtopicの中身を確認&lt;/p>
&lt;pre>&lt;code class="language-shell">(docker) rostopic echo /camera/color/image_raw
(docker) rostopic echo /scan
&lt;/code>&lt;/pre>
&lt;p>rvizを用いて可視化&lt;/p>
&lt;pre>&lt;code class="language-shell">(docker) rviz
&lt;/code>&lt;/pre>
&lt;/p>
&lt;/details>
&lt;details class="spoiler " id="spoiler-6">
&lt;summary>【開発PC】topicのpublish(配信)&lt;/summary>
&lt;p>&lt;p>topic&lt;code>/cmd_vel&lt;/code>の情報を確認&lt;/p>
&lt;pre>&lt;code class="language-shell">(docker) rostopic info /cmd_vel
&lt;/code>&lt;/pre>
&lt;p>topic&lt;code>/cmd_vel&lt;/code>の型を確認&lt;/p>
&lt;pre>&lt;code class="language-shell">(docker) rostopic type /cmd_vel
&lt;/code>&lt;/pre>
&lt;p>geometry_msgs/Twist型 &lt;a href="http://docs.ros.org/en/noetic/api/geometry_msgs/html/msg/Twist.html">http://docs.ros.org/en/noetic/api/geometry_msgs/html/msg/Twist.html&lt;/a>&lt;/p>
&lt;p>topic&lt;code>/cmd_vel&lt;/code>をpublish&lt;/p>
&lt;pre>&lt;code class="language-shell">(docker) rostopic pub /cmd_vel geometry_msgs/Twist &amp;quot;linear:
x: 1.0
y: 0.0
z: 0.0
angular:
x: 0.0
y: 0.0
z: 0.0&amp;quot;
&lt;/code>&lt;/pre>
&lt;p>topicをスクリプトからpublish&lt;/p>
&lt;pre>&lt;code class="language-shell">(docker) rosrun navigation_tutorial simple_control.py
&lt;/code>&lt;/pre>
&lt;p>try it! &lt;code>simple_control.py&lt;/code>の中身を読んでコードを変更してみよう&lt;/p>
&lt;/p>
&lt;/details></description></item><item><title>ロボットシステムにおけるセンシング・アクチュエーション・通信③</title><link>https://matsuolab.github.io/roomba_hack/course/chap3/sensing3/</link><pubDate>Tue, 05 Apr 2022 00:00:00 +0000</pubDate><guid>https://matsuolab.github.io/roomba_hack/course/chap3/sensing3/</guid><description>&lt;p>複数のセンサを組み合わせてよりかしこくロボットを動かしてみよう&lt;/p>
&lt;h2 id="learn">Learn&lt;/h2>
&lt;h3 id="lidarのスキャンデータを使って障害物を回避してみよう">LiDARのスキャンデータを使って，障害物を回避してみよう&lt;/h3>
&lt;p>次に，LiDARでスキャンしたデータを使って，障害物を回避するようなプログラムを作ってみましょう．&lt;/p>
&lt;h4 id="lidarスキャンのメッセージscanの中身を見てみよう">LiDARスキャンのメッセージ（&lt;code>/scan&lt;/code>）の中身を見てみよう&lt;/h4>
&lt;p>LiDARは，Light Detection And Rangingの略で，レーザ光を使って離れた場所にある物体形状や距離を測定するためのセンサです．
近年では，自動車の自動運転にも用いられることの多いセンサの一つです．&lt;/p>
&lt;p>roombaに搭載されたLiDARセンサ（rplidar）の値は，&lt;code>/scan&lt;/code>のトピックに流れていて，&lt;code>rostopic echo /scan&lt;/code>をしてみるとメッセージとしてどんな情報が流れているかわかります．&lt;/p>
&lt;p>大きなデータなので今回はテキストに掲載するのは省略しますが，&lt;code>rostopic type /scan&lt;/code>をしてみると，メッセージとして，&lt;code>sensor_msgs/LaserScan&lt;/code>型が使われていることがわかります．
&lt;details class="spoiler " id="spoiler-0">
&lt;summary>&lt;code>rostopic type /scan&lt;/code>&lt;/summary>
&lt;p>&lt;pre>&lt;code class="language-bash">root@dynamics:~/roomba_hack# rostopic type /scan
sensor_msgs/LaserScan
&lt;/code>&lt;/pre>
&lt;/p>
&lt;/details>&lt;/p>
&lt;p>&lt;code>sensor_msgs/LaserScan&lt;/code>型の定義を確認してみましょう．
メッセージ型の定義は，&lt;a href="http://docs.ros.org/en/melodic/api/sensor_msgs/html/msg/LaserScan.html" target="_blank" rel="noopener">ドキュメント&lt;/a>のほか，&lt;code>rosmsg info sensor_msgs/LaserScan&lt;/code>することでもコマンドから確認できます．
&lt;details class="spoiler " id="spoiler-1">
&lt;summary>&lt;code>rosmsg info sensor_msgs/LaserScan&lt;/code>&lt;/summary>
&lt;p>&lt;pre>&lt;code class="language-bash">root@dynamics:~/roomba_hack# rosmsg info sensor_msgs/LaserScan
std_msgs/Header header
uint32 seq
time stamp
string frame_id
float32 angle_min
float32 angle_max
float32 angle_increment
float32 time_increment
float32 scan_time
float32 range_min
float32 range_max
float32[] ranges
float32[] intensities
&lt;/code>&lt;/pre>
&lt;/p>
&lt;/details>&lt;/p>
&lt;p>&lt;code>angle_min&lt;/code>にはスキャンの開始角度，&lt;code>angle_max&lt;/code>にはスキャンの終了角度がラジアンで記録されています．
&lt;code>angle_increment&lt;/code>は，計測した間隔がラジアンで記録されています．
&lt;code>range_max&lt;/code>にはスキャンの間で検出された最大の距離，&lt;code>range_min&lt;/code>には最小の距離がメートルで記録されています．&lt;/p>
&lt;h4 id="rvizでlidarスキャンの値を可視化してみよう">rvizでLiDARスキャンの値を可視化してみよう&lt;/h4>
&lt;p>rvizでLiDARのスキャン結果を可視化してみましょう．&lt;/p>
&lt;p>&lt;code>LaserScan&lt;/code>をAddして，&lt;code>topic&lt;/code>に&lt;code>/scan&lt;/code>を設定すると，以下のように，ロボットを中心にLiDARによって計測された障害物が赤く表示されます．&lt;/p>
&lt;figure id="figure-lidarスキャンをrvizで可視化">
&lt;div class="d-flex justify-content-center">
&lt;div class="w-100" >&lt;img src="../lidar_scan.png" alt="LiDARスキャンをrvizで可視化" loading="lazy" data-zoomable />&lt;/div>
&lt;/div>&lt;figcaption>
LiDARスキャンをrvizで可視化
&lt;/figcaption>&lt;/figure>
&lt;h4 id="lidarを使って障害物を回避しよう">LiDARを使って障害物を回避しよう&lt;/h4>
&lt;p>それでは，LiDARスキャン&lt;code>/scen&lt;/code>の情報を使った制御の実装の例として&lt;code>navigation_tutorial&lt;/code>パッケージの中の&lt;code>avoidance.py&lt;/code>を見てみましょう（&lt;a href="https://github.com/matsuolab/roomba_hack/blob/master/catkin_ws/src/navigation_tutorial/scripts/avoidance.py" target="_blank" rel="noopener">github&lt;/a>）．&lt;/p>
&lt;p>このプログラムでは，LiDARを使って進行方向に存在する障害物を見つけ，それを回避しながら進むようにロボットを制御しています．具体的には，&lt;/p>
&lt;ul>
&lt;li>ロボットの進行方向に物体がなかったら直進&lt;/li>
&lt;li>ロボットの右側に障害物があったら左回転&lt;/li>
&lt;li>ロボットの左側に障害物があったら右回転&lt;/li>
&lt;/ul>
&lt;p>することで障害物を回避（ぶつかる前に方向転換）しています．&lt;/p>
&lt;p>では，プログラムの中身を見ていきます．&lt;/p>
&lt;p>&lt;a href="../sensing2/">&lt;code>/odom&lt;/code>を使った制御の場合&lt;/a>と同様に，ノードを定義する際に，コマンドを送るパブリッシャと，LiDARスキャンのデータを読み取るサブスクライバを作成します．&lt;/p>
&lt;pre>&lt;code class="language-python">class Avoidance:
def __init__(self):
rospy.init_node('avoidance', anonymous=True)
# Publisher
self.cmd_vel_pub = rospy.Publisher('/planner/cmd_vel', Twist, queue_size=10)
# Subscriber
scan_sub = rospy.Subscriber('/scan', LaserScan, self.callback_scan)
self.min_range = None
&lt;/code>&lt;/pre>
&lt;p>&lt;code>/scan&lt;/code>のコールバックは，&lt;/p>
&lt;pre>&lt;code class="language-python"> def callback_scan(self, data):
fov = np.deg2rad(60)
min_range = data.range_max
min_idx = -1
angle = data.angle_min
for idx, r in enumerate(data.ranges):
angle += data.angle_increment
if -fov&amp;lt;angle&amp;lt;fov:
if r&amp;lt;min_range:
min_range = r
min_idx = idx
if min_idx &amp;lt; len(data.ranges)/2.0:
self.direction = &amp;quot;RIGHT&amp;quot;
else:
self.direction = &amp;quot;LEFT&amp;quot;
self.min_range = min_range
&lt;/code>&lt;/pre>
&lt;p>となっており，正面から左右60度の範囲内で最も短い距離を&lt;code>self.min_range&lt;/code>に格納し，それが右側にあるのか左側にあるのかを&lt;code>self.direction&lt;/code>に格納しています．．&lt;/p>
&lt;p>このプログラムを実行すると&lt;code>process&lt;/code>メソッドが（0.1秒おきに）常に実行されます．&lt;/p>
&lt;pre>&lt;code class="language-python"> def process(self):
r = rospy.Rate(10)
while not rospy.is_shutdown():
vel = Twist()
if self.min_range is not None:
if self.min_range &amp;gt;= 0.4:
vel.linear.x = 0.2
vel.angular.z = 0.0
else:
vel.linear.x = 0.0
if self.direction == &amp;quot;RIGHT&amp;quot;:
vel.angular.z = 0.5
elif self.direction == &amp;quot;LEFT&amp;quot;:
vel.angular.z = -0.5
self.cmd_vel_pub.publish(vel)
rospy.sleep(0.1)
&lt;/code>&lt;/pre>
&lt;p>&lt;code>process&lt;/code>メソッド内部では，格納された&lt;code>self.min_range&lt;/code>が0.4（メートル）より大きい場合は，ロボットの前に何もないと判断して直進，小さい場合は，&lt;code>self.direction&lt;/code>の値を見て，&lt;code>RIGHT&lt;/code>であれば右に障害物があると判断して左回転，&lt;code>LEFT&lt;/code>であれば左に障害物があると判断して右回転するようなプログラムになっています．&lt;/p>
&lt;p>それでは，実際にLiDARを使って障害物を回避するプログラムを実行してみましょう．&lt;/p>
&lt;h2 id="演習">演習&lt;/h2>
&lt;h3 id="rosメッセージの可視化">ROSメッセージの可視化&lt;/h3>
&lt;details class="spoiler " id="spoiler-3">
&lt;summary>【開発PC】topicの確認&lt;/summary>
&lt;p>&lt;p>&lt;code>/scan&lt;/code>の型を確認&lt;/p>
&lt;pre>&lt;code class="language-shell">(docker) rostopic type /scan
&lt;/code>&lt;/pre>
&lt;p>&lt;code>/scan&lt;/code>の中身を確認&lt;/p>
&lt;pre>&lt;code class="language-shell">(docker) rostopic echo /scan
&lt;/code>&lt;/pre>
&lt;/p>
&lt;/details>
&lt;details class="spoiler " id="spoiler-4">
&lt;summary>LiDARスキャンを使ったフィードバック制御&lt;/summary>
&lt;p>&lt;p>&lt;code>avoidance.py&lt;/code>を実行してみよう．&lt;/p>
&lt;p>このプログラムを動かすときには，コントローラの&lt;code>Y&lt;/code>ボタンを押してから&lt;code>B&lt;/code>ボタンを押して&lt;code>auto&lt;/code>モードにしておきましょう．&lt;/p>
&lt;p>今回はせっかくなので，launchfileから起動してみましょう．s
このlaunchfileは，&lt;code>navigation_tutorial&lt;/code>パッケージの中の&lt;code>launch&lt;/code>フォルダの中にある&lt;code>avoidance.launch&lt;/code>に記述されています（&lt;a href="https://github.com/matsuolab/roomba_hack/blob/master/catkin_ws/src/navigation_tutorial/launch/avoidance.launch">github&lt;/a>）．&lt;/p>
&lt;pre>&lt;code class="language-shell">(docker) roslaunch navigation_tutorial avoidance
&lt;/code>&lt;/pre>
&lt;p>ロボットの進行方向に障害物があるときに，それを避けるように方向転換したら成功です．&lt;/p>
&lt;p>try it! &lt;code>avoidance.py&lt;/code>の中身を読んでコードを変更してみよう&lt;/p>
&lt;/p>
&lt;/details></description></item><item><title>ROSとは</title><link>https://matsuolab.github.io/roomba_hack/course/chap1/ros/</link><pubDate>Sat, 22 Jan 2022 00:00:00 +0000</pubDate><guid>https://matsuolab.github.io/roomba_hack/course/chap1/ros/</guid><description>&lt;p>ロボット開発によく用いられるROSの概要を理解する&lt;/p>
&lt;h2 id="learn">Learn&lt;/h2>
&lt;h3 id="rosの概要">ROSの概要&lt;/h3>
&lt;p>ROS(Robot Operating System)は、ロボット・アプリケーション作成を支援するライブラリとツールを提供するミドルウェアです。
具体的には以下にあげるものをROSは提供しています。&lt;/p>
&lt;ul>
&lt;li>
&lt;p>メッセージ通信&lt;/p>
&lt;p>プロセス間、コンピュータ間の通信ライブラリが提供されています。用途に応じて、多対多や一対多、非同期、同期などの通信形態を選択することができます。&lt;/p>
&lt;/li>
&lt;li>
&lt;p>デバイスドライバ&lt;/p>
&lt;p>ロボットに搭載される多くのセンサやアクチュエータがROSのAPIで標準化された形で提供されています。&lt;/p>
&lt;p>&lt;a href="https://github.com/ros-drivers">https://github.com/ros-drivers&lt;/a>
&lt;a href="http://wiki.ros.org/Sensors">http://wiki.ros.org/Sensors&lt;/a>&lt;/p>
&lt;/li>
&lt;li>
&lt;p>ライブラリ&lt;/p>
&lt;p>ロボットを動作させるソフトウェア(ナビゲーション、マニピュレーション)の基本機能の大半が提供されています。&lt;/p>
&lt;/li>
&lt;li>
&lt;p>視覚化ツール&lt;/p>
&lt;p>ロボットの内部状態やセンサ出力を2次元、3次元で視覚化するRvizや3次元動力学シミュレータのGazeboなどが提供されています。&lt;/p>
&lt;/li>
&lt;li>
&lt;p>パッケージ管理&lt;/p>
&lt;p>多種多様なプログラミング言語(python, C++, &amp;hellip;)、依存関係で記述されたプログラム(パッケージ)同士を統合的にセットアップ、ビルド、テスト、リリースすることが可能です。&lt;/p>
&lt;p>たとえば、経路計画など処理が重いプロセスはC++で、画像認識など機械学習系のプロセスはpythonで実装し、それらプロセス間の通信を容易に実装できる。&lt;/p>
&lt;/li>
&lt;/ul>
&lt;h3 id="rosのメッセージ通信">ROSのメッセージ通信&lt;/h3>
&lt;p>ロボットシステムでは、多数のプログラムを並列に実行し、それぞれがデータをやりとりします。
それらのプログラム間の通信ライブラリをROSは提供します。&lt;/p>
&lt;ul>
&lt;li>
&lt;p>ノード(node)&lt;/p>
&lt;p>ROSでは、一つのプログラム単位を「ノード(node)」と呼びます。
ノードは、ROSクライアントライブラリを用いて、他のノードとデータをやりとりします。
ROSクライアントライブラリは異なるプログラミング言語で記述されたノードがやりとりできるようにしています。
ノードは、次に述べるトピックの配信・購読、またはサービスの提供・使用が可能です。&lt;/p>
&lt;/li>
&lt;li>
&lt;p>トピック(topic)&lt;/p>
&lt;p>ROSでの、標準的なデータ通信の経路を「トピック(topic)」と呼びます。
ノードはメッセージをトピックへ向けて配信(Publish)し、同様に購読する(Subscribe)ことでトピックからメッセージを受け取ることができます。&lt;/p>
&lt;p>トピックには名前が付けられ、同じトピックに複数のノードがデータを送り、複数のノードがデータを受け取ることができます。&lt;/p>
&lt;/li>
&lt;li>
&lt;p>メッセージ(message)&lt;/p>
&lt;p>トピックへ配信したり、購読したりするときのROSのデータ型のことを「メッセージ(message)」と呼びます。
メッセージの型はmsgファイルに記述されており、使用言語に依存しないデータ形式になっています。&lt;/p>
&lt;p>以下に、物体やロボットの位置を表す時によく用いる&lt;code>geomemtry_msgs/PoseStamped&lt;/code>型のmsgファイルを示します。
位置情報の時間や座標フレームの情報が含まれるheaderと座標位置を表すposeで定義されています。&lt;/p>
&lt;pre>&lt;code>std_msgs/Header header
uint32 seq
time stamp
string frame_id
geometry_msgs/Pose pose
geometry_msgs/Point position
float64 x
float64 y
float64 z
geometry_msgs/Quaternion orientation
float64 x
float64 y
float64 z
float64 w
&lt;/code>&lt;/pre>
&lt;/li>
&lt;li>
&lt;p>サービス(service)&lt;/p>
&lt;p>「サービス(service)」はノードが他のノードとお互いに通信するための一つの手段です。
サービスを提供しているノードに引数を渡して、関数の実行結果を戻り値として受け取ることができます。&lt;/p>
&lt;p>呼び出される側のノードは、サービス名とデータ形式の宣言を「アドバタイズ(advertise)」し、呼び出す側のノードは、サービスを「コール(call)」します。&lt;/p>
&lt;p>サービスにおいて送受信されるデータの型はsrvファイルに記述されています。
メッセージと同様使用言語に依存しないデータ形式ですが、メッセージと異なるのは、引数と戻り値の二つの形式を定義する必要があるところです。&lt;/p>
&lt;p>以下に、srvの例として&lt;code>std_srvs/SetBool&lt;/code>を示します。
このように引数と戻り値の間に&lt;code>---&lt;/code>を入れて定義します。&lt;/p>
&lt;pre>&lt;code>bool data
---
bool success
string message
&lt;/code>&lt;/pre>
&lt;/li>
&lt;li>
&lt;p>ROSマスタ(ROS master)&lt;/p>
&lt;p>「ROSマスタ(ROS master)」は、ノード、トピックおよびサービスの名前登録を行い、それぞれのノードが他のノードから見えるようにする役割を担っています。
通信するノード名とトピック名およびサービス名の対応が決定した後、ノード同士が「peer-to-peer」で通信します。&lt;/p>
&lt;p>ROSマスタとノード間の通信はXML-RPCを用いて行われます。
ROSマスタを起動するには「roscore」というコマンドを実行します。&lt;/p>
&lt;/li>
&lt;li>
&lt;p>パラメータサーバ(parameter server)&lt;/p>
&lt;p>「パラメータサーバ(parameter server)」は、設定データを複数のノードで共有するための軽量なサーバです。
各ノードのパラメータを、パラメータサーバで一括して管理できます。
パラメータサーバもROSマスタ同様に「roscore」コマンドで起動します。&lt;/p>
&lt;p>パラメータサーバで扱える型は、整数・小数・真偽値・辞書・リストになります。&lt;/p>
&lt;/li>
&lt;li>
&lt;p>ROSのデータ通信のまとめ&lt;/p>
&lt;/li>
&lt;/ul>
&lt;figure id="figure-ros通信">
&lt;div class="d-flex justify-content-center">
&lt;div class="w-100" >&lt;img src="../ros_communication.png" alt="ROS通信" loading="lazy" data-zoomable />&lt;/div>
&lt;/div>&lt;figcaption>
ROS通信
&lt;/figcaption>&lt;/figure>
&lt;!-- ### デバイスドライバ
- カメラ
- LiDAR
- IMU -->
&lt;h3 id="rosと連動するソフトウェア">ROSと連動するソフトウェア&lt;/h3>
&lt;p>ROSは以下のソフトウェアと連動して使うためのパッケージが提供されています。&lt;/p>
&lt;ul>
&lt;li>
&lt;p>OpenCV&lt;/p>
&lt;p>コンピュータビジョンの標準的なライブラリ。&lt;/p>
&lt;p>OpenCVのデータ形式である、MatクラスとROSのメッセージ形式を変換するcv_bridgeや３次元座標上の物体を２次元画像上に投影する機能であるimage_geometryといったパッケージ(vision_opencv)が提供されています。&lt;/p>
&lt;/li>
&lt;li>
&lt;p>PCL(Point Cloud Library)&lt;/p>
&lt;p>3次元点群処理のライブラリ。&lt;/p>
&lt;p>OpenCV同様PCLのデータ形式とROSのメッセージ形式を変換するパッケージが提供されています。&lt;/p>
&lt;/li>
&lt;li>
&lt;p>OpenSLAM, Navigation Stack&lt;/p>
&lt;p>移動ロボットの自己位置推定と地図生成を同時に行うSLAM(Simultaneous Localization and Mapping)のソースコードを公開するためのプラットフォームと、。&lt;/p>
&lt;p>ROSではOpenSLAMで実装されているgmappingパッケージのラッパーやそれと連携して自律走行を実現するnavigationメタパッケージが提供されています。&lt;/p>
&lt;/li>
&lt;li>
&lt;p>Move it&lt;/p>
&lt;/li>
&lt;/ul>
&lt;h3 id="視覚化ツール">視覚化ツール&lt;/h3>
&lt;ul>
&lt;li>rqt&lt;/li>
&lt;/ul>
&lt;figure id="figure-rqt-window">
&lt;div class="d-flex justify-content-center">
&lt;div class="w-100" >&lt;img src="../ros_gui.png" alt="rqt window" loading="lazy" data-zoomable />&lt;/div>
&lt;/div>&lt;figcaption>
rqt window
&lt;/figcaption>&lt;/figure>
&lt;!-- http://wiki.ros.org/rqt -->
&lt;ul>
&lt;li>rviz&lt;/li>
&lt;/ul>
&lt;div style="position: relative; padding-bottom: 56.25%; height: 0; overflow: hidden;">
&lt;iframe src="https://www.youtube.com/embed/i--Sd4xH9ZE" style="position: absolute; top: 0; left: 0; width: 100%; height: 100%; border:0;" allowfullscreen title="YouTube Video">&lt;/iframe>
&lt;/div>
&lt;!-- http://wiki.ros.org/ja/rviz -->
&lt;ul>
&lt;li>gazebo&lt;/li>
&lt;/ul>
&lt;!-- ### パッケージ管理
- プログラミング言語
- rosdep
- -->
&lt;h2 id="演習">演習&lt;/h2>
&lt;details class="spoiler " id="spoiler-3">
&lt;summary>roomba driverを起動し、動作していることを確認する&lt;/summary>
&lt;p>&lt;ul>
&lt;li>
&lt;p>roombaにアクセスする&lt;/p>
&lt;pre>&lt;code class="language-sh">ssh roommba
&lt;/code>&lt;/pre>
&lt;/li>
&lt;li>
&lt;p>docker containerを起動する&lt;/p>
&lt;pre>&lt;code class="language-sh">cd ~/workspace/roomba_hack
./RUN-DOCKER-CONTAINER.sh
&lt;/code>&lt;/pre>
&lt;/li>
&lt;li>
&lt;p>roomba driverなどを起動するlaunchファイルを起動する&lt;/p>
&lt;pre>&lt;code class="language-sh">roslaunch roomma_bringup roomba_bringup.launch
&lt;/code>&lt;/pre>
&lt;/li>
&lt;li>
&lt;p>正常に起動できているかを確認&lt;/p>
&lt;pre>&lt;code class="language-sh">rosnode list
rostopic list
rostopic echo /odom
rqt_graph
&lt;/code>&lt;/pre>
&lt;/li>
&lt;/ul>
&lt;/p>
&lt;/details>
&lt;details class="spoiler " id="spoiler-4">
&lt;summary>コントローラーを使って、ロボットを動かす&lt;/summary>
&lt;p>&lt;ul>
&lt;li>
&lt;p>コントローラーを起動&lt;/p>
&lt;pre>&lt;code class="language-sh">roslauunch roomba_teleop roomaba_teleop.launch
&lt;/code>&lt;/pre>
&lt;/li>
&lt;li>
&lt;p>コントローラのモード&lt;/p>
&lt;ul>
&lt;li>移動・停止&lt;/li>
&lt;li>自動・マニュアル&lt;/li>
&lt;li>ドッキング・アンドッキング&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>
&lt;p>コントローラによる操縦&lt;/p>
&lt;ul>
&lt;li>
&lt;p>移動ロック解除&lt;/p>
&lt;p>L2を押している時のみ移動コマンドが動作します。&lt;/p>
&lt;/li>
&lt;li>
&lt;p>左ジョイスティック
縦方向で前進速度(手前に倒すとバック)、横方向は回転速度に対応しています。&lt;/p>
&lt;/li>
&lt;li>
&lt;p>左矢印
それぞれ、一定に低速度で前進・後退・回転します。&lt;/p>
&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>
&lt;p>正常に起動できているかを確認&lt;/p>
&lt;pre>&lt;code class="language-sh">rosnode list
rostopic list
rostopic echo /cmd_vel
rqt_graph
rviz
&lt;/code>&lt;/pre>
&lt;/li>
&lt;/ul>
&lt;/p>
&lt;/details></description></item><item><title>Navigation</title><link>https://matsuolab.github.io/roomba_hack/course/chap4/navigation/</link><pubDate>Fri, 01 Jan 2021 00:00:00 +0000</pubDate><guid>https://matsuolab.github.io/roomba_hack/course/chap4/navigation/</guid><description>&lt;p>ロボットシステムの開発環境に使われている要素の概要を理解する&lt;/p>
&lt;h2 id="learn">Learn&lt;/h2>
&lt;h3 id="navigationシステム">Navigationシステム&lt;/h3>
&lt;h3 id="cost-map">Cost Map&lt;/h3>
&lt;h3 id="global-path-planning">Global Path Planning&lt;/h3>
&lt;h3 id="local-path-planning">Local Path Planning&lt;/h3>
&lt;h2 id="演習">演習&lt;/h2>
&lt;details class="spoiler " id="spoiler-0">
&lt;summary>Dockerfileにnavigationを追加してBuildする&lt;/summary>
&lt;p>&lt;/p>
&lt;/details>
&lt;details class="spoiler " id="spoiler-1">
&lt;summary>navigationをlaunchして、rviz上で指定した位置までナビゲーションさせてみる&lt;/summary>
&lt;p>&lt;/p>
&lt;/details>
&lt;details class="spoiler " id="spoiler-2">
&lt;summary>navigationをlaunchして、map座標系の位置を指定してナビゲーションさせてみる&lt;/summary>
&lt;p>&lt;/p>
&lt;/details>
&lt;details class="spoiler " id="spoiler-3">
&lt;summary>navigationのparamをチューニングする&lt;/summary>
&lt;p>&lt;/p>
&lt;/details></description></item><item><title>Jian Yang and Monica Hall Win the Best Paper Award at Wowchemy 2020</title><link>https://matsuolab.github.io/roomba_hack/post/20-12-02-icml-best-paper/</link><pubDate>Wed, 02 Dec 2020 00:00:00 +0000</pubDate><guid>https://matsuolab.github.io/roomba_hack/post/20-12-02-icml-best-paper/</guid><description>&lt;p>Congratulations to Jian Yang and Monica Hall for winning the Best Paper Award at the 2020 Conference on Wowchemy for their paper “Learning Wowchemy”.&lt;/p>
&lt;p>Lorem ipsum dolor sit amet, consectetur adipiscing elit. Integer tempus augue non tempor egestas. Proin nisl nunc, dignissim in accumsan dapibus, auctor ullamcorper neque. Quisque at elit felis. Vestibulum ante ipsum primis in faucibus orci luctus et ultrices posuere cubilia curae; Aenean eget elementum odio. Cras interdum eget risus sit amet aliquet. In volutpat, nisl ut fringilla dignissim, arcu nisl suscipit ante, at accumsan sapien nisl eu eros.&lt;/p>
&lt;p>Sed eu dui nec ligula bibendum dapibus. Nullam imperdiet auctor tortor, vel cursus mauris malesuada non. Quisque ultrices euismod dapibus. Aenean sed gravida risus. Sed nisi tortor, vulputate nec quam non, placerat porta nisl. Nunc varius lobortis urna, condimentum facilisis ipsum molestie eu. Ut molestie eleifend ligula sed dignissim. Duis ut tellus turpis. Praesent tincidunt, nunc sed congue malesuada, mauris enim maximus massa, eget interdum turpis urna et ante. Morbi sem nisl, cursus quis mollis et, interdum luctus augue. Aliquam laoreet, leo et accumsan tincidunt, libero neque aliquet lectus, a ultricies lorem mi a orci.&lt;/p>
&lt;p>Mauris dapibus sem vel magna convallis laoreet. Donec in venenatis urna, vitae sodales odio. Praesent tortor diam, varius non luctus nec, bibendum vel est. Quisque id sem enim. Maecenas at est leo. Vestibulum tristique pellentesque ex, blandit placerat nunc eleifend sit amet. Fusce eget lectus bibendum, accumsan mi quis, luctus sem. Etiam vitae nulla scelerisque, eleifend odio in, euismod quam. Etiam porta ullamcorper massa, vitae gravida turpis euismod quis. Mauris sodales sem ac ultrices viverra. In placerat ultrices sapien. Suspendisse eu arcu hendrerit, luctus tortor cursus, maximus dolor. Proin et velit et quam gravida dapibus. Donec blandit justo ut consequat tristique.&lt;/p></description></item><item><title>Richard Hendricks Wins First Place in the Wowchemy Prize</title><link>https://matsuolab.github.io/roomba_hack/post/20-12-01-wowchemy-prize/</link><pubDate>Tue, 01 Dec 2020 00:00:00 +0000</pubDate><guid>https://matsuolab.github.io/roomba_hack/post/20-12-01-wowchemy-prize/</guid><description>&lt;p>Congratulations to Richard Hendricks for winning first place in the Wowchemy Prize.&lt;/p>
&lt;p>Lorem ipsum dolor sit amet, consectetur adipiscing elit. Integer tempus augue non tempor egestas. Proin nisl nunc, dignissim in accumsan dapibus, auctor ullamcorper neque. Quisque at elit felis. Vestibulum ante ipsum primis in faucibus orci luctus et ultrices posuere cubilia curae; Aenean eget elementum odio. Cras interdum eget risus sit amet aliquet. In volutpat, nisl ut fringilla dignissim, arcu nisl suscipit ante, at accumsan sapien nisl eu eros.&lt;/p>
&lt;p>Sed eu dui nec ligula bibendum dapibus. Nullam imperdiet auctor tortor, vel cursus mauris malesuada non. Quisque ultrices euismod dapibus. Aenean sed gravida risus. Sed nisi tortor, vulputate nec quam non, placerat porta nisl. Nunc varius lobortis urna, condimentum facilisis ipsum molestie eu. Ut molestie eleifend ligula sed dignissim. Duis ut tellus turpis. Praesent tincidunt, nunc sed congue malesuada, mauris enim maximus massa, eget interdum turpis urna et ante. Morbi sem nisl, cursus quis mollis et, interdum luctus augue. Aliquam laoreet, leo et accumsan tincidunt, libero neque aliquet lectus, a ultricies lorem mi a orci.&lt;/p>
&lt;p>Mauris dapibus sem vel magna convallis laoreet. Donec in venenatis urna, vitae sodales odio. Praesent tortor diam, varius non luctus nec, bibendum vel est. Quisque id sem enim. Maecenas at est leo. Vestibulum tristique pellentesque ex, blandit placerat nunc eleifend sit amet. Fusce eget lectus bibendum, accumsan mi quis, luctus sem. Etiam vitae nulla scelerisque, eleifend odio in, euismod quam. Etiam porta ullamcorper massa, vitae gravida turpis euismod quis. Mauris sodales sem ac ultrices viverra. In placerat ultrices sapien. Suspendisse eu arcu hendrerit, luctus tortor cursus, maximus dolor. Proin et velit et quam gravida dapibus. Donec blandit justo ut consequat tristique.&lt;/p></description></item><item><title/><link>https://matsuolab.github.io/roomba_hack/admin/config.yml</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://matsuolab.github.io/roomba_hack/admin/config.yml</guid><description/></item><item><title/><link>https://matsuolab.github.io/roomba_hack/contact/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://matsuolab.github.io/roomba_hack/contact/</guid><description/></item></channel></rss>